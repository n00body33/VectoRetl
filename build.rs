use std::{collections::HashSet, env, fs::File, io::Write, path::Path};

struct TrackedEnv {
    tracked: HashSet<String>,
}

impl TrackedEnv {
    pub fn new() -> Self {
        Self {
            tracked: HashSet::new(),
        }
    }

    pub fn get_env_var(&mut self, name: impl Into<String>) -> Option<String> {
        let name = name.into();
        let result = std::env::var(&name).ok();
        self.tracked.insert(name);
        result
    }

    pub fn emit_rerun_stanzas(&self) {
        for env_var in &self.tracked {
            println!("cargo:rerun-if-env-changed={}", env_var);
        }
    }
}

struct BuildConstants {
    values: Vec<(String, String, String)>,
}

impl BuildConstants {
    pub fn new() -> Self {
        Self { values: Vec::new() }
    }

    pub fn add_constant<S1, S2, S3>(&mut self, name: S1, desc: S2, value: Option<S3>)
    where
        S1: Into<String>,
        S2: Into<String>,
        S3: Into<String>,
    {
        if let Some(value) = value {
            let name = name.into();
            let desc = desc.into();
            let value = value.into();

            self.values.push((name, desc, value));
        }
    }

    pub fn write_to_file(self, file_name: impl AsRef<Path>) -> std::io::Result<()> {
        let base_dir = env::var("OUT_DIR").expect("OUT_DIR not present in build script!");
        let dest_path = Path::new(&base_dir).join(file_name);

        let mut output_file = File::create(&dest_path)?;
        output_file.write_all(
            "// AUTOGENERATED CONSTANTS. SEE BUILD.RS AT REPOSITORY ROOT. DO NOT MODIFY.\n"
                .as_ref(),
        )?;

        for (name, desc, value) in self.values {
            let full = format!(
                "#[doc=r#\"{}\"#]\npub const {}: &str = \"{}\";\n",
                desc, name, value
            );
            output_file.write_all(full.as_ref())?;
        }

        output_file.flush()?;
        output_file.sync_all()?;

        Ok(())
    }
}

fn main() {
    // Always rerun if the build script itself changes.
    println!("cargo:rerun-if-changed=build.rs");

    #[cfg(any(feature = "sources-vector", feature = "sinks-vector"))]
    {
        println!("cargo:rerun-if-changed=proto/vector.proto");
        let mut prost_build = prost_build::Config::new();
        prost_build.btree_map(&["."]);

        tonic_build::configure()
            .compile_with_config(
                prost_build,
                &["lib/vector-core/proto/event.proto", "proto/vector.proto"],
                &["proto/", "lib/vector-core/proto/"],
            )
            .unwrap();
    }

    // We keep track of which environment variables we slurp in, and then emit stanzas at the end to
    // inform Cargo when it needs to rerun this build script.  This allows us to avoid rerunning it
    // every single time unless something _actually_ changes.
    let mut tracker = TrackedEnv::new();
    let pkg_name = tracker.get_env_var("CARGO_PKG_NAME");
    let pkg_version = tracker.get_env_var("CARGO_PKG_VERSION");
    let pkg_description = tracker.get_env_var("CARGO_PKG_DESCRIPTION");
    let target = tracker.get_env_var("TARGET");
    let target_arch = tracker.get_env_var("CARGO_CFG_TARGET_ARCH");
    let build_desc = tracker.get_env_var("VECTOR_BUILD_DESC");

    // Gather up the constants and write them out to our build constants file.
    let mut constants = BuildConstants::new();
    constants.add_constant("PKG_NAME", "The full name of this package.", pkg_name);
    constants.add_constant(
        "PKG_VERSION",
        "The full version of this package.",
        pkg_version,
    );
    constants.add_constant(
        "PKG_DESCRIPTION",
        "The description of this package.",
        pkg_description,
    );
    constants.add_constant(
        "TARGET",
        "The target triple being compiled for. (e.g. x86_64-pc-windows-msvc)",
        target,
    );
    constants.add_constant(
        "TARGET_ARCH",
        "The target architecture being compiled for. (e.g. x86_64)",
        target_arch,
    );
    constants.add_constant(
        "VECTOR_BUILD_DESC",
        "Special build description, related to versioned releases.",
        build_desc,
    );
    constants
        .write_to_file("built.rs")
        .expect("Failed to write build-time constants file!");

    // Emit the aforementioned stanzas.
    tracker.emit_rerun_stanzas();
}
