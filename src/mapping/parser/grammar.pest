mapping = _{ SOI ~ statement ~ (NEWLINE+ ~ statement)* ~ NEWLINE* ~ EOI }

statement = _{ assignment | function | if_statement }

assignment = { dot_target_path ~ "=" ~ query_arithmetic }

///////////
// PATHS //
///////////

// Query path with coalesce support: `.foo.(bar | "@baz")[3]`
query_segment = _{ (path_segment | path_coalesce) }
query_path = ${ query_segment ~ ("." ~ query_segment)*  }
dot_query_path = ${ "." ~ query_path }

// Target path without coalesce support: `.foo.bar."@baz"[3]`
target_segment = _{ path_segment }
target_path = ${ target_segment ~ ("." ~ target_segment)* }
dot_target_path = ${ "." ~ target_path }

// Grouping of path segments: `foo.bar."@baz"[3]`
path_segment = !{ path_field_kind ~ path_index* }
path_coalesce = !{ "(" ~ path_field_kind ~ ("|" ~ path_field_kind)+ ~ ")" }

// Field names, regular and quoted: `baz`, `"@baz"`
path_field_kind = _{ (path_field | path_field_quoted) }
path_field = { (ASCII_ALPHA | "_" | "-" )+ }
path_field_quoted = { "\"" ~ inner_quoted_string ~ "\"" }

// Array indexing: `foo[2]`
path_index = ${ "[" ~ inner_path_index ~ "]" }
inner_path_index = { ASCII_DIGIT+ }

////////////////
// STATEMENTS //
////////////////

if_statement = {
    "if" ~ query_arithmetic ~ "{" ~ NEWLINE* ~
        statement ~
    NEWLINE* ~ "}" ~ ( "else" ~ "{" ~ NEWLINE* ~
        statement ~
    NEWLINE* ~ "}" )?
}

///////////////
// FUNCTIONS //
///////////////

function = {
    deletion |
    only_fields |
    merge
}

deletion = { "del(" ~ dot_query_path ~ ("," ~ dot_query_path)* ~ ")" }
only_fields = { "only_fields(" ~ dot_query_path ~ ("," ~ dot_query_path)* ~ ")" }
merge = { "merge(" ~ dot_query_path ~ "," ~ query_arithmetic ~ ("," ~ query_arithmetic)? ~ ")" }

ident = @{ ASCII_ALPHANUMERIC ~ ( ASCII_ALPHANUMERIC | "_" )* }

query_function = ${ ident ~ "(" ~ inner_function? ~ ")"  }

inner_function = !{ argument_list }

argument_list = _{ argument ~ ("," ~ argument)* }

argument = { positional_item | keyword_item }

positional_item = { query_arithmetic }

keyword_item = { ident ~ "=" ~ query_arithmetic }

////////////////
// PRIMITIVES //
////////////////

group = { "(" ~ query_arithmetic ~ ")" }

value = _{ string | float | integer | boolean | null }

boolean = { "true" | "false" }

null = { "null" }

string = ${ "\"" ~ inner_quoted_string ~ "\"" }
inner_quoted_string = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "n" | "t")
    // TODO: Eventually expand this to allow more escape sequences.
    // | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    // | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

integer = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

float = @{
    "-"?
    ~ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ ((("." ~ ASCII_DIGIT*) ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?)
        | (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+))
}

not_operator = { "!" ~ query_leaf }

///////////
// QUERY //
///////////

query_leaf = _{ not_operator | value | dot_query_path | group | query_function }

// Arithmetic, broken down into tiers in order to support operator precedence.
// Operators of the same tier are resolved from left to right.

// Deepest tier is the highest order of precedence, we call this just 'query' as
// it'll appear in parser error messages.
arithmetic_operator_product = { "*" | "/" | "%" }
query = { query_leaf ~ (arithmetic_operator_product ~ query_leaf)* }

arithmetic_operator_sum = { "+" | "-" }
query_arithmetic_sum = { query ~ (arithmetic_operator_sum ~ query)* }

arithmetic_operator_compare = { ">=" | ">" | "<=" | "<" | "!=" | "==" }
query_arithmetic_compare = { query_arithmetic_sum ~ (arithmetic_operator_compare ~ query_arithmetic_sum)* }

arithmetic_operator_boolean = { "||" | "&&" }
query_arithmetic_boolean = { query_arithmetic_compare ~ (arithmetic_operator_boolean ~ query_arithmetic_compare)* }

query_arithmetic = _{ query_arithmetic_boolean }

///////////
// OTHER //
///////////

WHITESPACE = _{ " " | "\t" }
