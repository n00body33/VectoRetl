Most Vector sinks involve some form of network connectivity. Connecting to a
network requires more involved functionality than we have covered so far in
our basic sink. This tutorial will modify the sink created in the [previous
tutorial][tutorial_1] to send the events to an HTTP endpoint. We will cover a
number of Vector framework components that make adding this functionality easy.

# Imports

To start, update our imports to the following:

```rust
use std::task::Poll;

use crate::{
    config::{GenerateConfig, SinkConfig, SinkContext},
    http::HttpClient,
    internal_events::SinkRequestBuildError,
    sinks::util::{
        encoding::{write_all, Encoder},
        metadata::RequestMetadataBuilder,
        request_builder::EncodeResult,
        Compression, RequestBuilder, SinkBuilderExt,
    },
    sinks::Healthcheck,
};
use bytes::Bytes;
use futures::{future::BoxFuture, stream::BoxStream, StreamExt};
use vector_common::{
    finalization::{EventFinalizers, EventStatus, Finalizable},
    internal_event::CountByteSize,
    request_metadata::{MetaDescriptive, RequestMetadata},
};
use vector_config::configurable_component;
use vector_core::{
    config::{AcknowledgementsConfig, Input},
    event::Event,
    sink::{StreamSink, VectorSink},
    stream::DriverResponse,
    tls::TlsSettings,
};
```

# Configuration

First we want to update our config to allow an endpoint to be specified. Add
this field to the `BasicConfig` struct:

```rust
    /// The endpoint to send HTTP traffic to.
    #[configurable(metadata(
        docs::examples = "http://localhost:3000/",
        docs::examples = "http://example.com/endpoint/",
    ))]
    pub endpoint: String,
```

Every field in the configuration struct must have a doc comment (`///`).
These are used to generate documentation for the Sink. The metadata
attribute added here is used to generate examples for the documentation.
(This is possible because the config struct is annotated with
`#[configurable_component(sink("basic"))]`). Since the comments here are
used for for user-facing documentation they should be good grammar and be
correctly capitalized and punctuated.

We then want to update our sink to take the endpoint from the config. At the
same time let's create an `HttpClient` that will handle sending the data.
`HttpClient` is our wrapper over [`hyper`][hyper_docs] used to send data over
http.

Update the `BasicSink` struct to look like:

```rust
#[derive(Debug, Clone)]
struct BasicSink {
    endpoint: String,
    client: HttpClient,
}

impl BasicSink {
    pub fn new(config: &BasicConfig) -> Self {
        let tls = TlsSettings::from_options(&None).unwrap();
        let client = HttpClient::new(tls, &Default::default()).unwrap();
        let endpoint = config.endpoint.clone();

        Self { client, endpoint }
    }
}
```

# Encoder

Now we want to create an Encoder that will take our event and convert it
to raw bytes.

```rust
#[derive(Clone)]
struct BasicEncoder;
```

The Encoder must implement the `Encoder` trait:

```rust
impl Encoder<Event> for BasicEncoder {
    fn encode_input(
        &self,
        input: Event,
        writer: &mut dyn std::io::Write,
    ) -> std::io::Result<usize> {
    }
}
```

The `Encoder` trait is generic over the type of input that we are
expecting. In our case it is `Event` since we will be encoding a single
event at a time. Other Sinks may encode a `Vec<Event>`  if they are
sending batches of events, or they may send a completely different type
if each event is processed in some way prior to encoding.

The `encode_input` serializes the event to a String and writes these
bytes:

```rust
    fn encode_input(
        &self,
        input: Event,
        writer: &mut dyn std::io::Write,
    ) -> std::io::Result<usize> {
        let event = serde_json::to_string(&input).unwrap();
        write_all(writer, 1, event.as_bytes()).map(|()| event.len())
    }
```

# Request Builder

Next we create a request builder that turns the event into a request. The
request that we build here is a struct containing any data required by a [Tower
service][tower] that is responsible for actually sending the data  to the
sink's final destination external to Vector, in this case the HTTP endpoint..
We will build this service shortly.

The request looks like:

```rust
#[derive(Clone)]
struct BasicRequest {
    payload: Bytes,
    finalizers: EventFinalizers,
    metadata: RequestMetadata,
}
```

## Fields

The fields in the request are:

*payload* - the payload is the actual bytes that we will be sending out. These are the bytes
generated by our `BasicEncoder`.

*finalizers* - `EventFinalizers` is a collection of `Finalizers`. A `Finalizer` is used to track
the status of a given event and is used to support
[end to end acknowledgements](https://vector.dev/docs/about/under-the-hood/guarantees/#acknowledgement-guarantees).

*metadata* - the metadata contains additional data that is used to emit various metrics when
a request is successfully sent.


## Traits

We need to implement a number of traits for the request to access these fields:

```rust
impl MetaDescriptive for BasicRequest {
    fn get_metadata(&self) -> RequestMetadata {
        self.metadata
    }
}

impl Finalizable for BasicRequest {
    fn take_finalizers(&mut self) -> EventFinalizers {
        self.finalizers.take_finalizers()
    }
}
```

The request builder must implement the `RequestBuilder<>` trait:

```rust
impl RequestBuilder<Event> for BasicRequestBuilder {
```

There are a number of stages in the request builder process:

1. The input is split out into metadata and actual event data.
2. This event data is encoded using the encoder we created earlier.
3. The results from the encoding are passed along with the metadata to create
   the final request that is passed to the `Tower` service.

Here, the trait is generic over `Event` which is the input type that is
passed in to start the request building process.

## Associated types

There are a number of associated types:

```rust
    type Metadata = EventFinalizers;
    type Events = Event;
    type Encoder = BasicEncoder;
    type Payload = Bytes;
    type Request = BasicRequest;
    type Error = std::io::Error;
```

*Metadata* - any information to be passed while building the request
that is additional to the actual event being used. In this case we just need the
`EventFinalizers`.

*Events* - the event type passed to the `Encoder`.

*Encoder* - the type that is used to encode the event to create the final
payload. We are using the `BasicEncoder` described earlier.

*Payload* - the final data that is encoded.

*Request* - the type that is sent to the final service. This is the `BasicRequest`
we described earlier.

*Error* - any errors that are creating while encoding the event.

## Functions

The following functions for the `RequestBuilder` trait need implementing:

### compression

```rust
    fn compression(&self) -> Compression {
        Compression::None
    }
```

The payload for the built request can be compressed. Here we return
`Compression::None` to indicate that we will not be compressing.
`Compression::Gzip` and `Compression::Zlib` are available choices that we can
use according to what the external service can cater for.

### encoder

```rust
    fn encoder(&self) -> &Self::Encoder {
        &self.encoder
    }
```

We return the encoder to use. This is the `BasicEncoder` defined earlier.


### split_input

```rust
    fn split_input(
        &self,
        mut input: Event,
    ) -> (Self::Metadata, RequestMetadataBuilder, Self::Events) {
        let finalizers = input.take_finalizers();
        let metadata_builder = RequestMetadataBuilder::from_events(&input);
        (finalizers, metadata_builder, input)
    }
```

`split_input` takes the input and extracts the metadata from the events. In this
case we are returning the `input` parameter unprocessed.

This may not always be the case. For example, the `amqp` sink will initially
process the event to extract fields to be used to calculate the `amqp`
exchange to send the message to. The exchange is bundled with the event to
`split_input`. `split_input` splits that out into the event for encoding and
the metadata containing the exchange which will be used to route the message
when sending the event to an `amqp` server.

### build_request

```rust
    fn build_request(
        &self,
        metadata: Self::Metadata,
        request_metadata: RequestMetadata,
        payload: EncodeResult<Self::Payload>,
    ) -> Self::Request {
        BasicRequest {
            finalizers: metadata,
            payload: payload.into_payload(),
            metadata: request_metadata,
        }
    }
```

`build_request` is used to build the final request that will contain the encoded
payload and the metadata. The `BasicRequest` object we return here is passed to
our `Tower` service where the data is actually sent.

# Service

We need to create a [`Tower`][tower] service that is responsible for actually
sending our final encoded data.

```rust
struct BasicService {
    endpoint: String,
    client: HttpClient,
}
```

The two fields the service contains, `endpoint` and `client` are the `endpoint`
and `client` passed in from the `BasicSink` described earlier.

`BasicService` implements the `tower::Service` trait:

```rust
impl tower::Service<BasicRequest> for BasicService {
}
```

## Associated types

A number of associated types need defining:

```rust
    type Response = BasicResponse;
    type Error = &'static str;
    type Future = BoxFuture<'static, Result<Self::Response, Self::Error>>;
```

## Functions

*[poll_ready]* - is called used to indicate when the service is ready to send
data. This service has no reason to block, so we always return `Poll::Ready`.

```rust
    fn poll_ready(
        &mut self,
        _cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        Poll::Ready(Ok(()))
    }
```

*[call]* - where the data is actually sent over HTTP. It returns a future
that will be invoked to send the actual data.

```rust
    fn call(&mut self, request: BasicRequest) -> Self::Future {
        let byte_size = request.payload.len();
        let body = hyper::Body::from(request.payload);
        let req = http::Request::post(&self.endpoint)
            .header("Content-Type", "application/json")
            .body(body)
            .unwrap();

        let mut client = self.client.clone();

        Box::pin(async move {
            match client.call(req).await {
                Ok(response) => {
                    if response.status().is_success() {
                        Ok(BasicResponse { byte_size })
                    } else {
                        Err("received error response")
                    }
                }
                Err(_error) => Err("oops"),
            }
        })
    }
```

That future returns `BasicResponse`.

# BasicResponse

The return from our service must be an object that implements the `DriverResponse` trait.

```rust
struct BasicResponse {
    byte_size: usize,
}

impl DriverResponse for BasicResponse {
    fn event_status(&self) -> EventStatus {
        EventStatus::Delivered
    }

    fn events_sent(&self) -> CountByteSize {
        // (events count, byte size)
        CountByteSize(1, self.byte_size)
    }
}
```

Vector calls the methods in this trait to determine if the event was delivered successfully.
This is used to emit internal metrics and satisfy end to end acknowledgements.

# Sink

Finally, we need to update the `run_inner` method of our `BasicSink` trait.

```rust
    async fn run_inner(self: Box<Self>, input: BoxStream<'_, Event>) -> Result<(), ()> {
        let service = tower::ServiceBuilder::new().service(BasicService {
            client: self.client.clone(),
            endpoint: self.endpoint.clone(),
        });

        let sink = input
            .request_builder(
                None,
                BasicRequestBuilder {
                    encoder: BasicEncoder,
                },
            )
            .filter_map(|request| async move {
                match request {
                    Err(error) => {
                        emit!(SinkRequestBuildError { error });
                        None
                    }
                    Ok(req) => Some(req),
                }
            })
            .into_driver(service);

        sink.run().await
    }
```

After creating our service, we run a number of custom extension methods on `BoxStream` that
process the stream of events.

## request_builder

`request_builder` indicates which request builder to use to build our request. We pass in
the `BasicRequestBuilder` described earlier. The first parameter is the limit to the number
of concurrent request builders that should be in operation at any time. We pass `None` which
means no limit is applied.

## filter_map

If building the request errors, we want to emit an error and then filter the event from being
processed further.

## into_driver

The `Driver` is the final stage of the process that drives the interaction between the stream
of incoming events and the `BasicService` we created above.

# Running our sink

We can now run our new sink.

Let's run a test HTTP server to accept the responses our sink sends:

```sh
docker run -p 3000:3000 plork/httpdump
```

Our sink has a new configuration field for the endpoint. Update it to look like:

```yaml
sinks:
  basic:
    type: basic
    endpoint: http://localhost:3000
    inputs:
      - stdin
```

Then run Vector:

```sh
vdev run ./basic.yml
```

If we type something into the console, this should now be sent to our HTTP server:

```sh
METHOD:  POST
URI:     /

HEADERS:
content-type      application/json
user-agent        Vector/0.26.0 (x86_64-unknown-linux-gnu debug=full)
accept-encoding   identity
host              localhost:3000
content-length    131

BODY:
{"log":{"host":"computer","message":"zork","source_type":"stdin","timestamp":"2023-01-23T10:21:57.215019942Z"}}
```

[tutorial_1]: https://github.com/vectordotdev/vector/tree/master/docs/tutorials/sinsk/1_basic_sink.md
[tower]: https://docs.rs/tower/latest/tower/trait.Service.html
[hyper_docs]: https://docs.rs/hyper/latest/hyper/
[poll_ready]: https://docs.rs/tower/latest/tower/trait.Service.html#tymethod.poll_ready
[call]: https://docs.rs/tower/latest/tower/trait.Service.html#tymethod.call